{"ast":null,"code":"var _jsxFileName = \"/home/meriam/testwapp/WApplication/Partie Client/src/views/recorder/recordrtc-react/src/RecordPage.react.js\",\n    _s = $RefreshSig$();\n\nimport React, { useRef, useState, useEffect } from 'react';\nimport IconButton from '@material-ui/core/Button';\nimport StopIcon from '@material-ui/icons/Stop';\nimport { makeStyles } from '@material-ui/styles';\nimport FlipCameraIosIcon from '@material-ui/icons/FlipCameraIos';\nconst styles = makeStyles(theme => ({\n  icon: {\n    fontSize: '2.2rem',\n    color: '#5336B7'\n  }\n}));\nexport default function Camera(props) {\n  _s();\n\n  const [videoRef, setVideoRef] = useState(useRef());\n  const classes = styles();\n  const [blob, setBlob] = useState([]);\n  const [mediaStream, setMediaStream] = useState(null);\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [time, setTime] = useState(0);\n  const [videoRecorded, setVideoRecorded] = useState(false);\n  const [playableVideo, setPlayableVideo] = useState(null);\n  const [camIndex, setCamIndex] = useState(null);\n  const [camCount, setCamCount] = useState(1);\n  const {\n    onRecordingComplete\n  } = props;\n  const [canPlay, setCanPlay] = useState(true); //l'ouverture dde la cam \n\n  const openCam = async index => {\n    setCamIndex(index);\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const videoDevices = devices.filter(e => e.kind === 'videoinput');\n    setCamCount(videoDevices.length);\n    const CAPTURE_OPTIONS = {\n      audio: 'default',\n      video: {\n        facingMode: \"environment\",\n        deviceId: videoDevices[index].deviceId\n      }\n    };\n    const stream = await navigator.mediaDevices.getUserMedia(CAPTURE_OPTIONS);\n    setMediaStream(stream);\n    videoRef.current.srcObject = stream;\n    const recorder = new window.MediaRecorder(stream);\n    setMediaRecorder(recorder);\n    setCanPlay(true);\n  };\n\n  useEffect(() => {\n    openCam(0);\n  }, []);\n  useEffect(() => {\n    if (mediaStream && videoRef.current && !videoRef.current.srcObject) {\n      videoRef.current.srcObject = mediaStream;\n      const recorder = new window.MediaRecorder(mediaStream);\n      setMediaRecorder(recorder);\n      setCanPlay(true);\n    }\n  }, [mediaStream]);\n  useEffect(() => {\n    if (mediaRecorder) {\n      const ondataavailable = e => {\n        blob.push(e.data);\n      };\n\n      mediaRecorder.ondataavailable = ondataavailable;\n      mediaRecorder.start(10);\n    }\n  }, [mediaRecorder]);\n\n  function handleCanPlay() {\n    videoRef.current.play();\n  }\n\n  const MIME_TYPES = ['video/webm;codecs=\"vp8,opus\"', 'video/webm;codecs=h264', 'video/webm;codecs=vp9', 'video/webm'];\n\n  const getMimeType = () => {\n    const mimeType = window.MediaRecorder.isTypeSupported ? MIME_TYPES.find(window.MediaRecorder.isTypeSupported) : 'video/webm';\n    return mimeType || '';\n  };\n\n  const handleStop = () => {\n    const videoBlob = blob.length === 1 ? blob[0] : new window.Blob(blob, {\n      type: getMimeType()\n    });\n    props.onRecordingComplete(videoBlob);\n    setVideoRecorded(true);\n    setPlayableVideo(URL.createObjectURL(videoBlob));\n\n    if (mediaRecorder.state === 'recording') {\n      mediaRecorder.stop();\n    }\n  };\n\n  const flipCamera = () => {\n    mediaStream.getTracks().forEach(track => {\n      track.stop();\n    });\n    mediaRecorder.stop();\n    const i = (camIndex + 1) % camCount;\n    videoRef.current.load();\n    delete videoRef.current.srcObject; // empty source\n\n    openCam(i);\n  };\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 111,\n      columnNumber: 5\n    }\n  }, videoRecorded && playableVideo ? /*#__PURE__*/React.createElement(\"video\", {\n    width: \"100%\",\n    src: playableVideo,\n    autoPlay: true,\n    playsInline: true,\n    controls: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 7\n    }\n  }) : /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 115,\n      columnNumber: 9\n    }\n  }, canPlay && /*#__PURE__*/React.createElement(\"video\", {\n    width: \"100%\",\n    ref: videoRef,\n    onCanPlay: handleCanPlay,\n    autoPlay: true,\n    playsInline: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 117,\n      columnNumber: 7\n    }\n  }), camCount > 1 && /*#__PURE__*/React.createElement(IconButton, {\n    onClick: flipCamera,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 120,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(FlipCameraIosIcon, {\n    classes: {\n      root: classes.icon\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 121,\n      columnNumber: 13\n    }\n  })), /*#__PURE__*/React.createElement(IconButton, {\n    onClick: handleStop,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 124,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(StopIcon, {\n    classes: {\n      root: classes.icon\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 125,\n      columnNumber: 13\n    }\n  }))));\n}\n\n_s(Camera, \"4/X4AaASke89KRw2VOhOnRB62TM=\");\n\n_c = Camera;\n\nvar _c;\n\n$RefreshReg$(_c, \"Camera\");","map":{"version":3,"sources":["/home/meriam/testwapp/WApplication/Partie Client/src/views/recorder/recordrtc-react/src/RecordPage.react.js"],"names":["React","useRef","useState","useEffect","IconButton","StopIcon","makeStyles","FlipCameraIosIcon","styles","theme","icon","fontSize","color","Camera","props","videoRef","setVideoRef","classes","blob","setBlob","mediaStream","setMediaStream","mediaRecorder","setMediaRecorder","time","setTime","videoRecorded","setVideoRecorded","playableVideo","setPlayableVideo","camIndex","setCamIndex","camCount","setCamCount","onRecordingComplete","canPlay","setCanPlay","openCam","index","devices","navigator","mediaDevices","enumerateDevices","videoDevices","filter","e","kind","length","CAPTURE_OPTIONS","audio","video","facingMode","deviceId","stream","getUserMedia","current","srcObject","recorder","window","MediaRecorder","ondataavailable","push","data","start","handleCanPlay","play","MIME_TYPES","getMimeType","mimeType","isTypeSupported","find","handleStop","videoBlob","Blob","type","URL","createObjectURL","state","stop","flipCamera","getTracks","forEach","track","i","load","root"],"mappings":"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","sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport IconButton from '@material-ui/core/Button';\nimport StopIcon from '@material-ui/icons/Stop';\nimport { makeStyles } from '@material-ui/styles';\nimport FlipCameraIosIcon from '@material-ui/icons/FlipCameraIos';\nconst styles = makeStyles((theme) => ({\n  icon:{\n    fontSize: '2.2rem',\n    color: '#5336B7',\n},\n})\n)\n\nexport default function Camera(props) {\n  const [videoRef, setVideoRef] = useState(useRef());\n  const classes = styles()\n  const [blob, setBlob] = useState([]);\n  const [mediaStream, setMediaStream] = useState(null);\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [time, setTime] = useState(0);\n  const [videoRecorded, setVideoRecorded] = useState(false);\n  const [playableVideo, setPlayableVideo] = useState(null);\n  const [camIndex, setCamIndex] = useState(null);\n  const [camCount, setCamCount] = useState(1);\n  const { onRecordingComplete } = props;\n  const [canPlay, setCanPlay] = useState(true);\n  //l'ouverture dde la cam \n  const openCam = async (index) => {\n    setCamIndex(index);\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const videoDevices = devices.filter(e => e.kind === 'videoinput');\n    setCamCount(videoDevices.length)\n    const CAPTURE_OPTIONS = {\n      audio: 'default',\n      video: { facingMode: \"environment\", deviceId: videoDevices[index].deviceId },\n    };\n    const stream = await navigator.mediaDevices.getUserMedia(CAPTURE_OPTIONS);\n    setMediaStream(stream);\n    videoRef.current.srcObject = stream;\n    const recorder = new window.MediaRecorder(stream);\n    setMediaRecorder(recorder);\n    setCanPlay(true); \n  }\n  useEffect(() =>{\n    openCam(0);\n  }, [])\n  \n  useEffect(() =>{\n    if (mediaStream && videoRef.current && !videoRef.current.srcObject) {\n      videoRef.current.srcObject = mediaStream;\n      const recorder = new window.MediaRecorder(mediaStream);\n      setMediaRecorder(recorder);\n      setCanPlay(true);\n    }\n    }, [mediaStream])\n  useEffect(() =>{\n    if(mediaRecorder) {\n      const ondataavailable = (e) => {\n        blob.push(e.data)\n      };\n      mediaRecorder.ondataavailable = ondataavailable;\n      mediaRecorder.start(10)\n    }  \n  }, [mediaRecorder])\n  function handleCanPlay() {\n    videoRef.current.play();\n  }\n\n  const MIME_TYPES = [\n    'video/webm;codecs=\"vp8,opus\"',\n    'video/webm;codecs=h264',\n    'video/webm;codecs=vp9',\n    'video/webm'\n  ]\n  \n  const getMimeType = () => {\n    const mimeType = window.MediaRecorder.isTypeSupported\n      ? MIME_TYPES.find(window.MediaRecorder.isTypeSupported)\n      : 'video/webm'\n\n    return mimeType || ''\n  }\n\n  const handleStop = () => {\n    const videoBlob =\n    blob.length === 1\n      ? blob[0]\n      : new window.Blob(blob, {\n        type: getMimeType()\n      })\n    \n\n    props.onRecordingComplete(videoBlob);\n    setVideoRecorded(true);\n    setPlayableVideo(URL.createObjectURL(videoBlob));\n    if(mediaRecorder.state === 'recording') {\n      mediaRecorder.stop();\n    }\n  };\n  const flipCamera = () => {\n    mediaStream.getTracks().forEach(track => {\n      track.stop();\n    });\n    mediaRecorder.stop();  \n    const i = (camIndex + 1) % camCount;\n    videoRef.current.load();\n    delete videoRef.current.srcObject; // empty source\n    openCam(i)\n  }\n  return (\n    <div>\n      {(videoRecorded && playableVideo) ?\n      <video width=\"100%\" src={playableVideo} autoPlay playsInline controls/>\n        :\n        <div>\n      { canPlay &&\n      <video width=\"100%\" ref={videoRef} onCanPlay={handleCanPlay} autoPlay playsInline />\n      }\n      {camCount > 1 &&\n      <IconButton onClick={flipCamera}>\n            <FlipCameraIosIcon classes={{root:classes.icon}}/>\n          </IconButton>\n      }\n        <IconButton onClick={handleStop}>\n            <StopIcon classes={{root:classes.icon}}/>\n          </IconButton>\n      </div>}\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}